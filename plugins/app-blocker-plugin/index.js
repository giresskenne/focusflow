const fs = require('fs');
const path = require('path');
const {
  withEntitlementsPlist,
  withDangerousMod,
  withXcodeProject,
  createRunOncePlugin,
} = require('@expo/config-plugins');
const { addFileToGroupAndLink } = require('@expo/config-plugins/build/ios/utils/Xcodeproj');

const PLUGIN_NAME = 'app-blocker-plugin';

function writeFileIfChanged(filePath, contents) {
  if (fs.existsSync(filePath) && fs.readFileSync(filePath, 'utf8') === contents) {
    return;
  }
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
  fs.writeFileSync(filePath, contents);
}

function withFamilyControlsEntitlement(config) {
  return withEntitlementsPlist(config, (config) => {
    if (String(process.env.EXPO_PUBLIC_ENABLE_IOS_BLOCKING_DEV).toLowerCase() === 'true') {
      config.modResults['com.apple.developer.family-controls'] = true;
    }
    return config;
  });
}

function withNativeSourceFiles(config) {
  return withDangerousMod(config, ['ios', (config) => {
    const { projectName, platformProjectRoot: iosRoot } = config.modRequest;
    if (!projectName || !iosRoot) throw new Error('Could not determine project name or root.');

    const swiftPath = path.join(iosRoot, projectName, 'AppBlocker.swift');
    const objcBridgePath = path.join(iosRoot, projectName, 'AppBlockerBridge.m');

    const swiftSource = `// Auto-generated by ${PLUGIN_NAME}
import Foundation
import React
#if canImport(FamilyControls)
import FamilyControls
import ManagedSettings
#endif

@objc(AppBlocker)
class AppBlocker: NSObject {
  @objc static func requiresMainQueueSetup() -> Bool { true }

  @objc func requestAuthorization(_ resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {
    #if canImport(FamilyControls)
    if #available(iOS 16.0, *) {
      AuthorizationCenter.shared.requestAuthorization { result in
        switch result {
        case .success():
          resolve(nil)
        case .failure(let error):
          reject("AUTH_ERROR", error.localizedDescription, error)
        }
      }
    } else {
      resolve(nil)
    }
    #else
    resolve(nil)
    #endif
  }
}
`;

    const objcBridgeSource = `// Auto-generated by ${PLUGIN_NAME}
#import <React/RCTBridgeModule.h>

@interface RCT_EXTERN_MODULE(AppBlocker, NSObject)
RCT_EXTERN_METHOD(requestAuthorization:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
@end
`;

    writeFileIfChanged(swiftPath, swiftSource);
    writeFileIfChanged(objcBridgePath, objcBridgeSource);

    return config;
  }]);
}

// THIS IS THE CRITICAL FUNCTION THAT WAS MISSING
function withBridgingHeader(config) {
  return withXcodeProject(config, (config) => {
    const { projectName } = config.modRequest;
    const project = config.modResults;
    const bridgingHeaderName = `${projectName}-Bridging-Header.h`;
    const bridgingHeaderPath = path.join(config.modRequest.platformProjectRoot, projectName, bridgingHeaderName);

    const contents = `#import <React/RCTBridgeModule.h>`;
    writeFileIfChanged(bridgingHeaderPath, contents);

    const buildConfigs = project.hash.project.objects.XCBuildConfiguration;
    for (const key in buildConfigs) {
      const cfg = buildConfigs[key];
      if (cfg.buildSettings && cfg.buildSettings.PRODUCT_NAME === `"${projectName}"`) {
        cfg.buildSettings.SWIFT_OBJC_BRIDGING_HEADER = `"$(SRCROOT)/$(PRODUCT_NAME)/${bridgingHeaderName}"`;
      }
    }
    return config;
  });
}

function withFileReferencesInXcode(config) {
  return withXcodeProject(config, (config) => {
    const { projectName } = config.modRequest;
    const project = config.modResults;

    const relSwift = `${projectName}/AppBlocker.swift`;
    const relObjc = `${projectName}/AppBlockerBridge.m`;

    // Add directly to the target's Sources build phase without specifying a group
    try { project.addSourceFile(relSwift, { target: project.getFirstTarget().uuid }); } catch {}
    try { project.addSourceFile(relObjc, { target: project.getFirstTarget().uuid }); } catch {}
    return config;
  });
}

// Main plugin that chains all the modifications together.
const withAppBlocker = (config) => {
  config = withFamilyControlsEntitlement(config);
  config = withNativeSourceFiles(config);
  // The order is critical: create the header, then add files to the project.
  config = withBridgingHeader(config);
  config = withFileReferencesInXcode(config);
  return config;
};

module.exports = createRunOncePlugin(withAppBlocker, PLUGIN_NAME, '1.0.0');
