// Expo config plugin to scaffold iOS AppBlocker native module and entitlements
// MVP: Adds optional App Group entitlement and injects Swift/Obj-C files for a
// placeholder native module (requests authorization; TODO apply shields).

const fs = require('fs');
const path = require('path');
const {
  withEntitlementsPlist,
  withDangerousMod,
  withXcodeProject,
  createRunOncePlugin,
} = require('@expo/config-plugins');

const PLUGIN_NAME = 'app-blocker-plugin';

function withAppGroupEntitlement(config, { appGroup } = {}) {
  return withEntitlementsPlist(config, (config) => {
    if (appGroup) {
      const groups = config.modResults['com.apple.security.application-groups'] || [];
      if (!groups.includes(appGroup)) {
        config.modResults['com.apple.security.application-groups'] = [...groups, appGroup];
      }
    }
    return config;
  });
}

function writeFileIfChanged(filePath, contents) {
  if (fs.existsSync(filePath)) {
    const current = fs.readFileSync(filePath, 'utf8');
    if (current === contents) return;
  } else {
    const dir = path.dirname(filePath);
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(filePath, contents);
}

function withNativeFiles(config) {
  return withDangerousMod(config, ['ios', (config) => {
    const projectName = config.modRequest.projectName;
    const iosRoot = config.modRequest.platformProjectRoot;
    if (!projectName || !iosRoot) return config;

    const swiftPath = path.join(iosRoot, projectName, 'AppBlocker.swift');
    const objcBridgePath = path.join(iosRoot, projectName, 'AppBlockerBridge.m');

  const swiftSource = `// Auto-generated by ${PLUGIN_NAME}. Edit safely.
// AppBlocker native bridge (scaffold). Uses iOS 16+ FamilyControls/ManagedSettings when available.
import Foundation
import React
import UIKit
#if canImport(FamilyControls)
import FamilyControls
import ManagedSettings
import SwiftUI
#endif

@objc(AppBlocker)
class AppBlocker: NSObject {
  private var isActive: Bool = false
#if canImport(FamilyControls)
  @available(iOS 16.0, *)
  private let store = ManagedSettingsStore()
  @available(iOS 16.0, *)
  private var selectedAppTokens: Set<ApplicationToken> = []
#endif

  @objc static func requiresMainQueueSetup() -> Bool { true }

  // Prepare user authorization for Family Controls
  @objc func requestAuthorization(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {
    #if canImport(FamilyControls)
    if #available(iOS 16.0, *) {
      AuthorizationCenter.shared.requestAuthorization { err in
        if let err = err { reject("auth_error", err.localizedDescription, err); return }
        resolve(nil)
      }
    } else {
      resolve(nil)
    }
    #else
    resolve(nil)
    #endif
  }

  @objc func startBlocking(_ appBundleIds: [String], resolver resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {
    #if canImport(FamilyControls)
    if #available(iOS 16.0, *) {
      // MVP: If no explicit selection, shield common categories (social & games) as a demo.
      // Later we will use selectedAppTokens from FamilyActivityPicker.
      do {
        let categories: Set<ApplicationCategoryToken> = [.socialNetworking, .games]
        store.shield.applicationCategories = .specific(categories)
        // Optionally also set selected apps if we have tokens
        if !selectedAppTokens.isEmpty {
          store.shield.applications = selectedAppTokens
        }
        self.isActive = true
        resolve(nil)
      }
    } else {
      resolve(nil)
    }
    #else
    self.isActive = true
    resolve(nil)
    #endif
  }

  @objc func stopBlocking(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {
    #if canImport(FamilyControls)
    if #available(iOS 16.0, *) {
      store.shield.applications = []
      store.shield.applicationCategories = .none
      self.isActive = false
      resolve(nil)
    } else {
      self.isActive = false
      resolve(nil)
    }
    #else
    self.isActive = false
    resolve(nil)
    #endif
  }

  @objc func isBlocking(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {
    resolve(self.isActive)
  }

  // Placeholder selection method that will later present FamilyActivityPicker.
  // For now, it simply resolves with the current in-memory selection (empty by default).
  @objc func selectApps(_ resolve: RCTPromiseResolveBlock, rejecter reject: RCTPromiseRejectBlock) {
    #if canImport(FamilyControls)
    if #available(iOS 16.0, *) {
      // TODO: Present FamilyActivityPicker and assign to selectedAppTokens
      // For now, return an empty array to JS
      resolve([])
    } else {
      resolve([])
    }
    #else
    resolve([])
    #endif
  }
}
`;

  const objcBridgeSource = `// Auto-generated by ${PLUGIN_NAME}. Bridges Swift module to React Native.
#import <React/RCTBridgeModule.h>
#import <React/RCTConvert.h>

@interface RCT_EXTERN_MODULE(AppBlocker, NSObject)
RCT_EXTERN_METHOD(requestAuthorization:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
RCT_EXTERN_METHOD(selectApps:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
RCT_EXTERN_METHOD(startBlocking:(NSArray *)appBundleIds resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
RCT_EXTERN_METHOD(stopBlocking:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
RCT_EXTERN_METHOD(isBlocking:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
@end
`;

    writeFileIfChanged(swiftPath, swiftSource);
    writeFileIfChanged(objcBridgePath, objcBridgeSource);

    return config;
  }]);
}

function withAddFilesToXcode(config) {
  return withXcodeProject(config, (config) => {
    const projectName = config.modRequest.projectName;
    const iosRoot = config.modRequest.platformProjectRoot;
    if (!projectName || !iosRoot) return config;

    const swiftFile = path.join(iosRoot, projectName, 'AppBlocker.swift');
    const objcFile = path.join(iosRoot, projectName, 'AppBlockerBridge.m');

    const project = config.modResults;
    const group = project.pbxGroupByName(projectName) || project.getFirstProject().firstProject.mainGroup;
    const targetUuid = project.getFirstTarget().uuid;

    function add(filePath) {
      const file = project.addSourceFile(path.basename(filePath), { target: targetUuid }, group.path);
      return file;
    }

    try { if (fs.existsSync(swiftFile)) add(swiftFile); } catch {}
    try { if (fs.existsSync(objcFile)) add(objcFile); } catch {}

    return config;
  });
}

const withAppBlocker = (config, props = {}) => {
  config = withAppGroupEntitlement(config, props);
  config = withNativeFiles(config);
  config = withAddFilesToXcode(config);
  return config;
};

module.exports = createRunOncePlugin(withAppBlocker, PLUGIN_NAME, '1.0.0');
